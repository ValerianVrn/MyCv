<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Architecture" xml:space="preserve">
    <value>Architecture</value>
  </data>
  <data name="ArchitectureIntroduction" xml:space="preserve">
    <value>Je vous présente ici l'architecture du site sur lequel vous naviguez.</value>
  </data>
  <data name="ArchitectureMe1" xml:space="preserve">
    <value>Ce que je peux vous apporter :</value>
  </data>
  <data name="ArchitectureMe2" xml:space="preserve">
    <value>- une conception qui s'appuie sur des références reconnues et qui s'adapte aux exigences du projet</value>
  </data>
  <data name="ArchitectureMe3" xml:space="preserve">
    <value>- une expertise sur CQRS/event sourcing</value>
  </data>
  <data name="ArchitectureMicroservice" xml:space="preserve">
    <value>Il s'agit d'une application basée sur des microservices qui utilisent deux patterns d'architecture du domain-driven design (DDD) : Command and Query Responsibility Segregation (CQRS) et event sourcing.</value>
  </data>
  <data name="ArchitectureReference1" xml:space="preserve">
    <value>Les développements s'appuient sur différentes références dont </value>
  </data>
  <data name="ArchitectureReference2" xml:space="preserve">
    <value>(Microsoft) ou encore des articles tels que ceux de</value>
  </data>
  <data name="CommandCommandStep" xml:space="preserve">
    <value>Création de la commande</value>
  </data>
  <data name="CommandCommandStepValidation" xml:space="preserve">
    <value>Validation par des règles basiques : note comprise entre 0 et 5.</value>
  </data>
  <data name="CommandDomainStep" xml:space="preserve">
    <value>Création de l'agrégat</value>
  </data>
  <data name="CommandDomainStepValidation" xml:space="preserve">
    <value>Vérification de la conformité des règles métiers : recommandation incohérente avec la note (note supérieure à 3 mais profil non recommandé).</value>
  </data>
  <data name="Commands" xml:space="preserve">
    <value>Commandes</value>
  </data>
  <data name="CommandSaveStep" xml:space="preserve">
    <value>Sauvegarde de l'agrégat</value>
  </data>
  <data name="CommandSaveStepValidation" xml:space="preserve">
    <value>On passe aux queries pour le résultat !</value>
  </data>
  <data name="CommandsDescription" xml:space="preserve">
    <value>Ce diagramme de séquence présente de manière simplifiée le processus d'écriture.</value>
  </data>
  <data name="CommandSendStep" xml:space="preserve">
    <value>Envoi de la requête POST</value>
  </data>
  <data name="CommandSendStepValidation" xml:space="preserve">
    <value>Validation via le formulaire (front-end) : champ de recommandation requis.</value>
  </data>
  <data name="CommandsExample" xml:space="preserve">
    <value>Commençons par créer une commande pour l'ajout d'un avis à propos de ce site :</value>
  </data>
  <data name="CommandsRecommendation" xml:space="preserve">
    <value>Recommanderiez-vous mon profil ?</value>
  </data>
  <data name="CommandsSatisfaction" xml:space="preserve">
    <value>Comment appréciez-vous ce site ?</value>
  </data>
  <data name="Conclusion" xml:space="preserve">
    <value>Conclusion</value>
  </data>
  <data name="Content" xml:space="preserve">
    <value>Contenu</value>
  </data>
  <data name="CQRSBenefits" xml:space="preserve">
    <value>Ce concept simple a plusieurs avantages : maintenabilité (séparation des responsabilités), scalabilité des couches de lecture et d'écriture indépendante, performance des opérations de lecture, validation des commandes et respect des règles métier...</value>
  </data>
  <data name="CQRSDefinition" xml:space="preserve">
    <value>CQRS est un pattern d'architecture qui sépare les "requêtes" (lecture) des "commandes" (écriture).</value>
  </data>
  <data name="CQRSDiagram" xml:space="preserve">
    <value>Ce diagramme de séquence présente de manière simplifiée les processus d'écriture puis de lecture déclenchés par de classiques appels REST.</value>
  </data>
  <data name="CQRSExample" xml:space="preserve">
    <value>Mais quoi de mieux qu'une mise en pratique ? C'est parti !</value>
  </data>
  <data name="CQRSService" xml:space="preserve">
    <value>Ici, le service "Rating" applique CQRS pour gérer les notes des visiteurs de ce site web.</value>
  </data>
  <data name="Date" xml:space="preserve">
    <value>Date</value>
  </data>
  <data name="Degrees" xml:space="preserve">
    <value>Diplômes</value>
  </data>
  <data name="EventSourcingBenefits" xml:space="preserve">
    <value>Il offre un historique complet, facilite le débogage et les requêtes temporelles, et permet de reconstruire l’état ou créer plusieurs vues.</value>
  </data>
  <data name="EventSourcingDefinition1" xml:space="preserve">
    <value>L’event sourcing est un pattern dans lequel les changements d’état sont enregistrés comme une séquence d’événements immuables plutôt que de modifier directement l’état courant. Un exemple très parlant est celui d'une </value>
  </data>
  <data name="EventSourcingDefinition2" xml:space="preserve">
    <value> pour laquelle l'état courant de l'échiquier est la résultante de chaque coup joué (évènement).</value>
  </data>
  <data name="EventSourcingDefinitionLink" xml:space="preserve">
    <value>partie d'échecs</value>
  </data>
  <data name="EventSourcingReadResult" xml:space="preserve">
    <value>La base de lecture est mise à jour sur chaque évènment pour sortir le top 3 des raisons qui vous font lire ceci :</value>
  </data>
  <data name="EventSourcingService" xml:space="preserve">
    <value>Ici, le service "Insight" applique CQRS + event sourcing pour gérer ce que vous attendez d'un profil et la raison de votre visite.</value>
  </data>
  <data name="EventSourcingWrite" xml:space="preserve">
    <value>Chaque évènement est stocké dans une base en append-only.</value>
  </data>
  <data name="EventSourcingWriteBenefits" xml:space="preserve">
    <value>En quoi est-ce génial ? On connaît non seulement l'état final mais on est aussi capable de rejouer tout l'historique ou encore déterminer l'état du système à un instant précis.</value>
  </data>
  <data name="EventSourcingWriteExample" xml:space="preserve">
    <value>Voyons comment cela se traduit avec cet exemple :</value>
  </data>
  <data name="EventSourcingWriteExampleInstructions" xml:space="preserve">
    <value>Faites glisser dans l'encadré le ou les raisons qui vous amènent et classer les par pertinence :</value>
  </data>
  <data name="EventSourcingWriteExampleResult" xml:space="preserve">
    <value>Voici le résultat du stockage dans l'event store :</value>
  </data>
  <data name="EventSourcingWriteIllustration" xml:space="preserve">
    <value>Cela peut s'avérer utile quelle que soit l'application : quel a été le parcours thérapeutique du patient ? Dans quel état étaient les drones au moment du crash ? Quelles actions le joueur a effectuées au moment du bug ? ...</value>
  </data>
  <data name="Experiences" xml:space="preserve">
    <value>Expériences</value>
  </data>
  <data name="Home" xml:space="preserve">
    <value>Accueil</value>
  </data>
  <data name="HomeHeader" xml:space="preserve">
    <value>Bonjour. Moi c'est Valérian.</value>
  </data>
  <data name="HomeIntroduction" xml:space="preserve">
    <value>Bienvenue sur mon CV interactif et minimaliste qui applique le DDD avec CQRS et event sourcing en C#/.NET.</value>
  </data>
  <data name="HomeSourceCode" xml:space="preserve">
    <value>N'hésitez pas à consulter le code source sur</value>
  </data>
  <data name="HomeStart" xml:space="preserve">
    <value>Et maintenant, place à la pratique</value>
  </data>
  <data name="Intent" xml:space="preserve">
    <value>Raison</value>
  </data>
  <data name="IntentBoredom" xml:space="preserve">
    <value>L'ennui</value>
  </data>
  <data name="IntentBoredomDescription" xml:space="preserve">
    <value>Je tue le temps (sans vouloir vous offenser !)</value>
  </data>
  <data name="IntentBrowsing" xml:space="preserve">
    <value>Portfolios tech</value>
  </data>
  <data name="IntentBrowsingDescription" xml:space="preserve">
    <value>Je parcours des portfolios tech</value>
  </data>
  <data name="IntentCollaboration" xml:space="preserve">
    <value>Collaboration</value>
  </data>
  <data name="IntentCollaborationDescription" xml:space="preserve">
    <value>Recherche d'une collaboration</value>
  </data>
  <data name="IntentCurious" xml:space="preserve">
    <value>Curiosité</value>
  </data>
  <data name="IntentCuriousDescription" xml:space="preserve">
    <value>Curieux de votre travail</value>
  </data>
  <data name="IntentFreelance" xml:space="preserve">
    <value>Recherche de freelance</value>
  </data>
  <data name="IntentFreelanceDescription" xml:space="preserve">
    <value>Je recherche des freelances</value>
  </data>
  <data name="IntentHelping" xml:space="preserve">
    <value>Coup de main</value>
  </data>
  <data name="IntentHelpingDescription" xml:space="preserve">
    <value>J'aide Valérian gratuitement, je suis sympa</value>
  </data>
  <data name="IntentMisclick" xml:space="preserve">
    <value>Misclick</value>
  </data>
  <data name="IntentMisclickDescription" xml:space="preserve">
    <value>Un misclick !</value>
  </data>
  <data name="IntentNetworking" xml:space="preserve">
    <value>Réseau</value>
  </data>
  <data name="IntentNetworkingDescription" xml:space="preserve">
    <value>J'agrandis mon réseau</value>
  </data>
  <data name="IntentPost" xml:space="preserve">
    <value>Suivi de post/discussion</value>
  </data>
  <data name="IntentPostDescription" xml:space="preserve">
    <value>Suite à un post/une discussion</value>
  </data>
  <data name="IntentRecruiting" xml:space="preserve">
    <value>Recrutement</value>
  </data>
  <data name="IntentRecruitingDescription" xml:space="preserve">
    <value>Je recrute</value>
  </data>
  <data name="IntentReputation" xml:space="preserve">
    <value>Réputation</value>
  </data>
  <data name="IntentReputationDescription" xml:space="preserve">
    <value>J'ai entendu parlé de vous</value>
  </data>
  <data name="IntentReviewing" xml:space="preserve">
    <value>Examination du CV</value>
  </data>
  <data name="IntentReviewingDescription" xml:space="preserve">
    <value>J'examine votre CV</value>
  </data>
  <data name="JobTitle" xml:space="preserve">
    <value>Leader technique C#/.NET</value>
  </data>
  <data name="Languages" xml:space="preserve">
    <value>Langue</value>
  </data>
  <data name="Microservice" xml:space="preserve">
    <value>Microservice</value>
  </data>
  <data name="MicroserviceAPI" xml:space="preserve">
    <value>Une gateway (YARP) pour éviter d'exposer directement les microservices et de les coupler à l'interface.</value>
  </data>
  <data name="MicroserviceAPIContent" xml:space="preserve">
    <value>Cet intermédiaire permet notamment d'éviter un couplage avec les microservices ou encore de sécuriser l'application en n'exposant pas les microservices.</value>
  </data>
  <data name="MicroserviceBackend" xml:space="preserve">
    <value>Deux microservices qui communiquent via RabbitMQ et utilisent différentes bases de données (EventStoreDB, MongoDB).</value>
  </data>
  <data name="MicroserviceBackendContent" xml:space="preserve">
    <value>Deux microservices qui communiquent via RabbitMQ et utilisent différentes bases de données (EventStoreDB, MongoDB)</value>
  </data>
  <data name="MicroserviceDescription" xml:space="preserve">
    <value>Voici une brève description de l'architecture microservice de ce projet:</value>
  </data>
  <data name="MicroserviceDocker" xml:space="preserve">
    <value>Les applications sont conteneurisées avec Docker et lancées via Docker Compose.</value>
  </data>
  <data name="MicroserviceFrontend" xml:space="preserve">
    <value>Une UI simple réalisée avec Blazor server et MudBlazor.</value>
  </data>
  <data name="MicroserviceFrontendContent" xml:space="preserve">
    <value>Je suis également à l'aise avec Bootstrap et j'ai déjà réalisé un site en ReactJS.</value>
  </data>
  <data name="MicroserviceReference" xml:space="preserve">
    <value>Mes développements sont largement inspirés de ce guide Microsoft qui m'a permis de comprendre et implémenter des applications microservices :</value>
  </data>
  <data name="No" xml:space="preserve">
    <value>Non</value>
  </data>
  <data name="PersonalLife" xml:space="preserve">
    <value>Vie personnelle</value>
  </data>
  <data name="Priority" xml:space="preserve">
    <value>Priorité</value>
  </data>
  <data name="Queries" xml:space="preserve">
    <value>Requêtes</value>
  </data>
  <data name="QueriesDescription" xml:space="preserve">
    <value>Le mécanisme des requêtes est plus direct :</value>
  </data>
  <data name="QueriesExample" xml:space="preserve">
    <value>Voyons maintenant quelles sont les dernières notes :</value>
  </data>
  <data name="RequiredAnswer" xml:space="preserve">
    <value>Réponse requise</value>
  </data>
  <data name="Testing" xml:space="preserve">
    <value>Test</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Type</value>
  </data>
  <data name="Update" xml:space="preserve">
    <value>Mettre à jour</value>
  </data>
  <data name="Validate" xml:space="preserve">
    <value>Valider</value>
  </data>
  <data name="Yes" xml:space="preserve">
    <value>Oui</value>
  </data>
  <data name="You" xml:space="preserve">
    <value>Vous</value>
  </data>
</root>